<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DreamApp — v4.4.6</title>
<style>
  :root{
    --bg:#0d1117;
    --panel:#0f1521;
    --panel-2:#111827;
    --text:#e6e7ea;
    --muted:#9aa3b2;
    --accent:#88a0ff;
    --border:#222a36;
    --dot:#6ee7b7;
  }
  html,body{height:100%;}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial;}
  *{box-sizing:border-box}

  /* Sidebar */
  .sidebar{position:fixed;left:0;top:0;bottom:0;width:280px;background:linear-gradient(180deg,#0f1521,#0c1120);border-right:1px solid var(--border);display:flex;flex-direction:column;z-index:500}
  .sidebar__head{display:flex;align-items:center;justify-content:space-between;padding:12px 12px;border-bottom:1px solid var(--border)}
  .badge{display:inline-flex;align-items:center;gap:8px;background:#0e1430;border:1px solid #1b2550;color:#c9d4ff;border-radius:10px;padding:4px 8px;font-weight:700}
  .menu{padding:12px;overflow:auto}
  .menu button{display:flex;align-items:center;gap:10px;width:100%;padding:10px 12px;margin:6px 0;background:transparent;border:1px solid var(--border);color:var(--text);border-radius:12px;cursor:pointer}
  .menu button .handle{opacity:.5}
  .menu button .btn-label{flex:1;text-align:left}
  .menu button.active{border-color:#2b3754;box-shadow:inset 0 0 0 1px #2b3754}
  .menu button .dot{width:8px;height:8px;border-radius:50%;background:transparent;border:1px solid #38517d}
  .menu button.active .dot{background:var(--dot);border-color:var(--dot)}

  /* Desktop area */
  main.desktop{margin-left:280px;padding:16px 16px 40px;position:relative}
  .win{position:absolute;background:var(--panel);border:1px solid var(--border);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.3);overflow:hidden}
  .win__head{display:flex;align-items:center;gap:8px;padding:10px 12px;border-bottom:1px solid var(--border);background:linear-gradient(180deg,#0f172a,#0d1424)}
  .win__title{font-weight:700}
  .win__close{margin-left:auto;background:rgba(255,255,255,.03);border:1px solid var(--border);color:var(--text);border-radius:8px;padding:4px 8px;cursor:pointer}
  .win__body{padding:12px}
  .win textarea,.win input,.win select{width:100%;background:var(--panel-2);border:1px solid var(--border);color:var(--text);border-radius:10px;padding:10px}
  .win textarea{min-height:120px;resize:vertical}
  .win .win__actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .btn{background:#151d31;border:1px solid var(--border);color:var(--text);border-radius:10px;padding:8px 10px;cursor:pointer}

  /* simple resizers (corners/edges) */
  .resizer{position:absolute}
  .r-n{top:-4px;left:8px;right:8px;height:8px;cursor:n-resize}
  .r-s{bottom:-4px;left:8px;right:8px;height:8px;cursor:s-resize}
  .r-e{right:-4px;top:8px;bottom:8px;width:8px;cursor:e-resize}
  .r-w{left:-4px;top:8px;bottom:8px;width:8px;cursor:w-resize}
  .r-ne{top:-6px;right:-6px;width:12px;height:12px;cursor:ne-resize}
  .r-nw{top:-6px;left:-6px;width:12px;height:12px;cursor:nw-resize}
  .r-se{bottom:-6px;right:-6px;width:12px;height:12px;cursor:se-resize}
  .r-sw{bottom:-6px;left:-6px;width:12px;height:12px;cursor:sw-resize}

  /* Scrollbars */
  *{scrollbar-width:thin;scrollbar-color:#1c2636 transparent}
  *::-webkit-scrollbar{width:10px;height:10px}
  *::-webkit-scrollbar-thumb{background:rgba(255,255,255,.06);border-radius:10px}
  *:hover::-webkit-scrollbar-thumb{background:rgba(255,255,255,.16)}

  /* Focus ring */
  :focus-visible{outline:2px solid rgba(136,160,255,.5);outline-offset:2px}
</style>

<!-- v4_4_6+ change: user badge style -->
<style>
#userBadge {
  position: fixed; top: 8px; right: 12px; z-index: 1200;
  background: rgba(120,140,255,0.12); color: #cfd8ff;
  border: 1px solid rgba(120,140,255,0.35);
  padding: 4px 8px; border-radius: 8px; font-size: 12px; font-weight: 600;
  pointer-events: none;
}
</style>
</head>
<body>

<!-- Sidebar -->
<aside class="sidebar" id="sidebar">
  <div class="sidebar__head">
    <div class="badge">DreamApp <span style="opacity:.7">v4.4.6</span></div>
  </div>
  <div class="menu" id="menu" aria-label="Drag to reorder">
    <button draggable="true" data-target="win-framework"><span class="handle">⋮⋮</span><span class="btn-label">Framework & Dream</span><span class="dot"></span></button>
    <button draggable="true" data-target="win-preview"><span class="handle">⋮⋮</span><span class="btn-label">Prompt Preview / Copy</span><span class="dot"></span></button>
    <button draggable="true" data-target="win-modelout"><span class="handle">⋮⋮</span><span class="btn-label">Model Output (paste)</span><span class="dot"></span></button>
    <button draggable="true" data-target="win-depthprompt"><span class="handle">⋮⋮</span><span class="btn-label">Depth Prompt</span><span class="dot"></span></button>
    <button draggable="true" data-target="win-depthout"><span class="handle">⋮⋮</span><span class="btn-label">Depth Output</span><span class="dot"></span></button>
    <button draggable="true" data-target="win-wcprompt"><span class="handle">⋮⋮</span><span class="btn-label">Waking Context Prompt</span><span class="dot"></span></button>
    <button draggable="true" data-target="win-wcout"><span class="handle">⋮⋮</span><span class="btn-label">Waking Context Output</span><span class="dot"></span></button>

    <!-- v4_4_6 fix: add menu items -->
    <button draggable="true" data-target="win-library">
      <span class="handle">⋮⋮</span><span class="btn-label">Library</span><span class="dot"></span>
    </button>
    <button draggable="true" data-target="win-storage-log">
      <span class="handle">⋮⋮</span><span class="btn-label">Storage Log</span><span class="dot"></span>
    </button>
    <button draggable="true" data-target="win-settings">
      <span class="handle">⋮⋮</span><span class="btn-label">Settings</span><span class="dot"></span>
    </button>
  </div>
</aside>

<!-- Desktop -->
<main class="desktop" id="desktop">
  <!-- Framework & Dream -->
  <section class="win" id="win-framework" style="left:320px;top:24px;width:520px;height:520px;">
    <header class="win__head">
      <div class="win__title">Framework & Dream</div>
      <button class="win__close" data-close="win-framework">✕</button>
    </header>
    <div class="win__body">
      <label>Dream text</label>
      <!-- Dream Name field will be injected above this textarea by the profiles script -->
      <textarea id="dream" placeholder="Type dream here…"></textarea>
    </div>
    <div class="resizer r-n"></div><div class="resizer r-s"></div>
    <div class="resizer r-e"></div><div class="resizer r-w"></div>
    <div class="resizer r-ne"></div><div class="resizer r-nw"></div>
    <div class="resizer r-se"></div><div class="resizer r-sw"></div>
  </section>

  <!-- Prompt Preview -->
  <section class="win" id="win-preview" style="left:860px;top:24px;width:520px;height:300px;">
    <header class="win__head"><div class="win__title">Prompt Preview / Copy</div><button class="win__close" data-close="win-preview">✕</button></header>
    <div class="win__body">
      <textarea id="promptPreview" placeholder="Preview builds here…" ></textarea>
      <div class="win__actions">
        <button class="btn" id="copyPreview">Copy</button>
      </div>
    </div>
    <div class="resizer r-n"></div><div class="resizer r-s"></div>
    <div class="resizer r-e"></div><div class="resizer r-w"></div>
    <div class="resizer r-ne"></div><div class="resizer r-nw"></div>
    <div class="resizer r-se"></div><div class="resizer r-sw"></div>
  </section>

  <!-- Model Output -->
  <section class="win" id="win-modelout" style="left:320px;top:560px;width:520px;height:340px;">
    <header class="win__head"><div class="win__title">Model Output (paste)</div><button class="win__close" data-close="win-modelout">✕</button></header>
    <div class="win__body">
      <textarea id="modelOutput" placeholder="Paste model output here…"></textarea>
      <div class="win__actions">
        <button class="btn" id="btnPlain">Plain</button>
        <button class="btn" id="btnStandard">Standard</button>
        <button class="btn" id="btnAdvanced">Advanced</button>
      </div>
    </div>
    <div class="resizer r-n"></div><div class="resizer r-s"></div>
    <div class="resizer r-e"></div><div class="resizer r-w"></div>
    <div class="resizer r-ne"></div><div class="resizer r-nw"></div>
    <div class="resizer r-se"></div><div class="resizer r-sw"></div>
  </section>

  <!-- Depth Prompt -->
  <section class="win" id="win-depthprompt" style="left:860px;top:340px;width:520px;height:240px;">
    <header class="win__head"><div class="win__title">Depth Prompt</div><button class="win__close" data-close="win-depthprompt">✕</button></header>
    <div class="win__body">
      <textarea id="depthPrompt" placeholder="Auto-built by depth buttons…"></textarea>
      <div class="win__actions"><button class="btn" id="copyDepthPrompt">Copy Depth prompt</button></div>
    </div>
    <div class="resizer r-n"></div><div class="resizer r-s"></div>
    <div class="resizer r-e"></div><div class="resizer r-w"></div>
    <div class="resizer r-ne"></div><div class="resizer r-nw"></div>
    <div class="resizer r-se"></div><div class="resizer r-sw"></div>
  </section>

  <!-- Depth Output -->
  <section class="win" id="win-depthout" style="left:860px;top:600px;width:520px;height:300px;">
    <header class="win__head"><div class="win__title">Depth Output</div><button class="win__close" data-close="win-depthout">✕</button></header>
    <div class="win__body">
      <textarea id="depthOutput" placeholder="Paste depth output…"></textarea>
    </div>
    <div class="resizer r-n"></div><div class="resizer r-s"></div>
    <div class="resizer r-e"></div><div class="resizer r-w"></div>
    <div class="resizer r-ne"></div><div class="resizer r-nw"></div>
    <div class="resizer r-se"></div><div class="resizer r-sw"></div>
  </section>

  <!-- Waking Context Prompt -->
  <section class="win" id="win-wcprompt" style="left:1400px;top:24px;width:520px;height:320px;">
    <header class="win__head"><div class="win__title">Waking Context Prompt</div><button class="win__close" data-close="win-wcprompt">✕</button></header>
    <div class="win__body">
      <textarea id="wakingContextPrompt" placeholder="Auto-builds from model output + context…"></textarea>
      <div class="win__actions"><button class="btn" id="copyWCPrompt">Copy</button></div>
    </div>
    <div class="resizer r-n"></div><div class="resizer r-s"></div>
    <div class="resizer r-e"></div><div class="resizer r-w"></div>
    <div class="resizer r-ne"></div><div class="resizer r-nw"></div>
    <div class="resizer r-se"></div><div class="resizer r-sw"></div>
  </section>

  <!-- Waking Context Output -->
  <section class="win" id="win-wcout" style="left:1400px;top:360px;width:520px;height:540px;">
    <header class="win__head"><div class="win__title">Waking Context Output</div><button class="win__close" data-close="win-wcout">✕</button></header>
    <div class="win__body">
      <textarea id="wakingContextOutput" placeholder="Paste waking-life–informed output here…"></textarea>
    </div>
    <div class="resizer r-n"></div><div class="resizer r-s"></div>
    <div class="resizer r-e"></div><div class="resizer r-w"></div>
    <div class="resizer r-ne"></div><div class="resizer r-nw"></div>
    <div class="resizer r-se"></div><div class="resizer r-sw"></div>
  </section>

  <!-- v4_4_6 fix: Library window -->
  <section class="win" id="win-library" style="left:1960px; top:24px; width:520px; height:420px;">
    <header class="win__head">
      <div class="win__title">Library</div>
      <button class="win__close" data-close="win-library">✕</button>
    </header>
    <div class="win__body">
      <div class="win__actions" style="display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap;">
        <button class="btn" id="libNew">New From Current</button>
        <button class="btn" id="libSave">Save Current</button>
        <button class="btn" id="libRefresh">Refresh</button>
      </div>
      <label>Saved Dreams</label>
      <div id="libraryList" style="background:var(--panel-2);border:1px solid var(--border);border-radius:10px; padding:6px; height:220px; overflow:auto;"></div>
      <div class="win__actions" style="display:flex;gap:8px;margin-top:8px;">
        <button class="btn" id="libLoad">Load Selected</button>
        <button class="btn" id="libDelete">Delete Selected</button>
      </div>
    </div>
    <div class="resizer r-n"></div><div class="resizer r-s"></div>
    <div class="resizer r-e"></div><div class="resizer r-w"></div>
    <div class="resizer r-ne"></div><div class="resizer r-nw"></div>
    <div class="resizer r-se"></div><div class="resizer r-sw"></div>
  </section>

  <!-- v4_4_6 fix: Storage Log window -->
  <section class="win" id="win-storage-log" style="left:1960px; top:460px; width:520px; height:320px;">
    <header class="win__head">
      <div class="win__title">Storage Log</div>
      <button class="win__close" data-close="win-storage-log">✕</button>
    </header>
    <div class="win__body">
      <textarea id="storageLog" placeholder="Log will appear here…" readonly style="min-height:220px;"></textarea>
      <div class="win__actions" style="display:flex;gap:8px;margin-top:8px;">
        <button class="btn" id="logClear">Clear Log</button>
      </div>
    </div>
    <div class="resizer r-n"></div><div class="resizer r-s"></div>
    <div class="resizer r-e"></div><div class="resizer r-w"></div>
    <div class="resizer r-ne"></div><div class="resizer r-nw"></div>
    <div class="resizer r-se"></div><div class="resizer r-sw"></div>
  </section>

  <!-- v4_4_6 fix: Settings window -->
  <section class="win" id="win-settings" style="left:1960px; top:800px; width:520px; height:280px;">
    <header class="win__head">
      <div class="win__title">Settings</div>
      <button class="win__close" data-close="win-settings">✕</button>
    </header>
    <div class="win__body">
      <label>Storage Mode</label>
      <div style="display:flex;flex-direction:column;gap:6px;margin-bottom:8px;">
        <label><input type="radio" name="storageMode" value="auto" checked> Auto (OPFS if available, else IndexedDB)</label>
        <label><input type="radio" name="storageMode" value="folder"> Connected Folder (Directory Picker)</label>
        <label><input type="radio" name="storageMode" value="idb"> IndexedDB (fallback)</label>
      </div>
      <div class="win__actions" style="display:flex;gap:8px;flex-wrap:wrap;">
        <button class="btn" id="connectFolder">Connect Folder…</button>
        <button class="btn" id="revokeFolder">Disconnect</button>
        <button class="btn" id="openFolder" title="Open a folder just to inspect">Open Folder</button>
      </div>
      <div style="margin-top:8px;">
        <div class="note">Status:</div>
        <div id="storageStatus" class="note">Initializing…</div>
      </div>
    </div>
    <div class="resizer r-n"></div><div class="resizer r-s"></div>
    <div class="resizer r-e"></div><div class="resizer r-w"></div>
    <div class="resizer r-ne"></div><div class="resizer r-nw"></div>
    <div class="resizer r-se"></div><div class="resizer r-sw"></div>
  </section>
</main>

<!-- Basic window and menu wiring -->
<script>
(function(){
  const $ = (s, r=document) => r.querySelector(s);
  const $$ = (s, r=document) => Array.from(r.querySelectorAll(s));
  // move/resize/close minimal behaviors
  $$('#desktop .win').forEach(win=>{
    const head = $('.win__head', win);
    let ox=0, oy=0, dragging=false;
    head.addEventListener('mousedown',e=>{ dragging=true; ox=e.clientX - win.offsetLeft; oy=e.clientY - win.offsetTop; win.style.zIndex = 999; });
    window.addEventListener('mouseup',()=>dragging=false);
    window.addEventListener('mousemove',e=>{ if(!dragging) return; win.style.left=(e.clientX-ox)+'px'; win.style.top=(e.clientY-oy)+'px'; });

    // resizers
    const res = (el, dx, dy)=>{
      let sx, sy, sw, sh, resizing=false;
      el.addEventListener('mousedown',e=>{e.stopPropagation(); resizing=true; sx=e.clientX; sy=e.clientY; sw=win.offsetWidth; sh=win.offsetHeight; ox=win.offsetLeft; oy=win.offsetTop;});
      window.addEventListener('mouseup',()=>resizing=false);
      window.addEventListener('mousemove',e=>{
        if(!resizing) return;
        const mx=e.clientX-sx, my=e.clientY-sy;
        if(dx==='e') win.style.width = Math.max(360, sw+mx)+'px';
        if(dx==='w'){ win.style.width=Math.max(360, sw-mx)+'px'; win.style.left=(ox+mx)+'px';}
        if(dy==='s') win.style.height = Math.max(220, sh+my)+'px';
        if(dy==='n'){ win.style.height=Math.max(220, sh-my)+'px'; win.style.top=(oy+my)+'px';}
      });
    };
    res($('.r-e',win),'e',null); res($('.r-w',win),'w',null); res($('.r-s',win),null,'s'); res($('.r-n',win),null,'n');
    res($('.r-se',win),'e','s'); res($('.r-sw',win),'w','s'); res($('.r-ne',win),'e','n'); res($('.r-nw',win),'w','n');

    // close
    $('.win__close', win)?.addEventListener('click',()=>{ win.style.display='none'; const id=win.id; const btn = document.querySelector(`.menu button[data-target="${id}"]`); btn?.classList.remove('active'); });
  });

  // menu toggle
  $$('#menu button').forEach(btn=>{
    const id = btn.getAttribute('data-target');
    btn.addEventListener('click', ()=>{ const w = document.getElementById(id); if(!w) return;
      const vis = w.style.display !== 'none';
      w.style.display = vis?'none':'block';
      btn.classList.toggle('active', !vis);
    });
    // on load: mark active if visible
    const w = document.getElementById(id);
    btn.classList.toggle('active', w && w.style.display !== 'none');
  });

  // copy helpers
  function flash(btn){
    const t=btn.textContent; btn.textContent='Copied!'; setTimeout(()=>btn.textContent=t,1500);
  }
  $('#copyPreview')?.addEventListener('click',()=>{ navigator.clipboard.writeText($('#promptPreview')?.value||''); flash($('#copyPreview')); });
  $('#copyDepthPrompt')?.addEventListener('click',()=>{ navigator.clipboard.writeText($('#depthPrompt')?.value||''); flash($('#copyDepthPrompt')); });
  $('#copyWCPrompt')?.addEventListener('click',()=>{ navigator.clipboard.writeText($('#wakingContextPrompt')?.value||''); flash($('#copyWCPrompt')); });

  // depth buttons: build rephrase prompt into Depth Prompt and bring to front
  function buildDepth(kind){
    const src = $('#modelOutput')?.value || '';
    const style = kind==='plain'?'Plain':'Advanced';
    const prompt = `Rephrase the following interpretation in ${style} style (preserve facts, adjust jargon density):\n\n---\n${src}`;
    $('#depthPrompt').value = prompt;
    const win = document.getElementById('win-depthprompt'); if(win){ win.style.display='block'; win.style.zIndex=1000; document.querySelector('.menu button[data-target="win-depthprompt"]')?.classList.add('active'); }
  }
  $('#btnPlain')?.addEventListener('click',()=>buildDepth('plain'));
  $('#btnStandard')?.addEventListener('click',()=>buildDepth('standard'));
  $('#btnAdvanced')?.addEventListener('click',()=>buildDepth('advanced'));

  // Waking-context prompt auto-build (live) from Model Output + Context
  function rebuildWCPrompt(){
    const mo = $('#modelOutput')?.value||'';
    const ctx = $('#wakingContextOutput')?.value||'';
    const s = [
      "Create a waking-life–informed revision of the dream interpretation.",
      "",
      "Instructions:",
      "- Start from the existing interpretation provided between <<<INTERPRETATION>>> markers.",
      "- Integrate the waking-life context provided between [[CONTEXT]] markers wherever it clarifies motives, tensions, or symbols.",
      "- Keep the same overall structure (Table of elements, then **Interpretation**, then **Concluding Insight**). If no table exists, produce one.",
      "- Stay educational and exploratory, not therapeutic. Do not add greetings or questions. Avoid advice or directives.",
      "- Maintain factual content from the original; only add context-aware links. Keep tone consistent with the framework.",
      "",
      "[[CONTEXT]]",
      ctx,
      "[[/CONTEXT]]",
      "",
      "<<<INTERPRETATION>>>",
      mo,
      "<<<END>>>"
    ].join("\n");
    $('#wakingContextPrompt').value = s;
  }
  ['modelOutput','wakingContextOutput'].forEach(id=>{
    document.getElementById(id)?.addEventListener('input', rebuildWCPrompt);
  });
  rebuildWCPrompt();

  // Library legacy buttons behavior (minimal placeholders)
  $('#libNew')?.addEventListener('click', ()=>{ const el=$('#dream')||$('#dreamText'); $('#libraryList').insertAdjacentHTML('afterbegin', `<label style="display:flex;gap:6px;align-items:center;padding:4px 0;"><input type="radio" name="dreamPick" value="untitled"> <span>untitled</span></label>`); });
  $('#libSave')?.addEventListener('click', ()=>{}); // superseded by Save Dream below
  $('#libRefresh')?.addEventListener('click', ()=>{}); // wired by profiles script
  $('#libLoad')?.addEventListener('click', ()=>{});     // superseded by Load Dream below
  $('#libDelete')?.addEventListener('click', ()=>{});
  $('#logClear')?.addEventListener('click', ()=>{ const el=$('#storageLog'); if(el) el.value=''; });
})();
</script>

<!-- v4_4_6 change: storage adapters + library (built 2025-09-16T02:33:11.203601Z) -->
<script>
(function(){
  const LOG = (msg) => {
    const el = document.getElementById('storageLog'); if(!el) return;
    const t = new Date().toISOString().replace('T',' ').replace('Z','');
    el.value += `[${t}] ${msg}\n`;
    el.scrollTop = el.scrollHeight;
  };
  const setStatus = (txt) => { const s = document.getElementById('storageStatus'); if(s) s.textContent = txt; };

  // IndexedDB tiny KV
  const idb = (() => {
    const DB='DreamAppDB_v1'; const STORE='kv';
    function open(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB,1); r.onupgradeneeded=()=>{ r.result.createObjectStore(STORE); }; r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
    async function put(k,v){ const db=await open(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).put(v,k); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }
    async function get(k){ const db=await open(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const req=tx.objectStore(STORE).get(k); req.onsuccess=()=>res(req.result??null); req.onerror=()=>rej(req.error); }); }
    async function del(k){ const db=await open(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).delete(k); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }
    async function keys(){ const db=await open(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const req=tx.objectStore(STORE).getAllKeys(); req.onsuccess=()=>res(req.result||[]); req.onerror=()=>rej(req.error); }); }
    return { put, get, del, keys };
  })();

  // Helpers
  function pathSegments(p){ return p.split('/').filter(Boolean); }

  // OPFS Adapter (Chromium)
  const OPFSAdapter = {
    name: 'opfs',
    async ensureDir(path){
      let dir = await navigator.storage.getDirectory();
      for(const seg of pathSegments(path)) dir = await dir.getDirectoryHandle(seg, { create:true });
      return dir;
    },
    async put(path, data){
      const segs = pathSegments(path); const fileName = segs.pop();
      const dir = await this.ensureDir(segs.join('/'));
      const fh = await dir.getFileHandle(fileName, { create:true });
      const w = await fh.createWritable(); await w.write(typeof data==='string'?data:JSON.stringify(data,null,2)); await w.close();
      LOG(`OPFS saved: ${path}`);
    },
    async get(path){
      const segs = pathSegments(path); const fileName = segs.pop();
      let dir = await navigator.storage.getDirectory();
      for(const s of segs) dir = await dir.getDirectoryHandle(s);
      const fh = await dir.getFileHandle(fileName);
      const f = await fh.getFile(); const txt = await f.text();
      try{ return JSON.parse(txt); }catch{ return txt; }
    },
    async remove(path){
      const segs=pathSegments(path); const name=segs.pop();
      let dir = await navigator.storage.getDirectory();
      for(const s of segs) dir = await dir.getDirectoryHandle(s);
      await dir.removeEntry(name); LOG(`OPFS removed: ${path}`);
    },
    async list(dirPath){
      let dir = await navigator.storage.getDirectory();
      for(const s of pathSegments(dirPath)) dir = await dir.getDirectoryHandle(s, { create:true });
      const out=[]; for await (const [name,handle] of dir.entries()) if(name) out.push(name);
      return out;
    }
  };

  // Directory Picker Adapter
  const FolderAdapter = {
    name: 'folder',
    dirHandle: null,
    async connect(){
      this.dirHandle = await window.showDirectoryPicker({ id:'DreamApp', mode:'readwrite' });
      await idb.put('folderHandle', this.dirHandle);
      LOG('Connected to folder');
      return true;
    },
    async restore(){
      const h = await idb.get('folderHandle'); if(h) this.dirHandle = h; return !!this.dirHandle;
    },
    async ensureDir(path){
      let dir = this.dirHandle; if(!dir) throw new Error('No folder connected');
      for(const seg of pathSegments(path)) dir = await dir.getDirectoryHandle(seg, { create:true });
      return dir;
    },
    async put(path,data){
      const segs=pathSegments(path); const fileName=segs.pop();
      const dir = await this.ensureDir(segs.join('/'));
      const fh = await dir.getFileHandle(fileName, { create:true });
      const w = await fh.createWritable(); await w.write(typeof data==='string'?data:JSON.stringify(data,null,2)); await w.close();
      LOG(`Folder saved: ${path}`);
    },
    async get(path){
      const segs=pathSegments(path); const fileName=segs.pop();
      let dir = this.dirHandle; if(!dir) throw new Error('No folder connected');
      for(const s of segs) dir = await dir.getDirectoryHandle(s);
      const fh = await dir.getFileHandle(fileName);
      const f = await fh.getFile(); const txt = await f.text();
      try{ return JSON.parse(txt); }catch{ return txt; }
    },
    async remove(path){
      const segs=pathSegments(path); const name=segs.pop();
      let dir = this.dirHandle; if(!dir) throw new Error('No folder connected');
      for(const s of segs) dir = await dir.getDirectoryHandle(s);
      await dir.removeEntry(name); LOG(`Folder removed: ${path}`);
    },
    async list(dirPath){
      let dir = this.dirHandle; if(!dir) throw new Error('No folder connected');
      for(const s of pathSegments(dirPath)) dir = await dir.getDirectoryHandle(s, { create:true });
      const out=[]; for await (const [name,handle] of dir.entries()) if(name) out.push(name);
      return out;
    }
  };

  // IndexedDB Fallback Adapter
  const IDBAdapter = {
    name: 'idb',
    async put(path,data){
      const str = typeof data==='string'?data:JSON.stringify(data,null,2);
      await idb.put('file:'+path, str);
      const man = (await idb.get('__manifest__'))||[];
      if(!man.includes(path)) { man.push(path); await idb.put('__manifest__', man); }
      LOG(`IDB saved: ${path}`);
    },
    async get(path){
      const txt = await idb.get('file:'+path); if(!txt) return null;
      try{ return JSON.parse(txt); }catch{ return txt; }
    },
    async remove(path){
      await idb.del('file:'+path);
      const man = (await idb.get('__manifest__'))||[];
      const i = man.indexOf(path); if(i>=0) man.splice(i,1);
      await idb.put('__manifest__', man);
      LOG(`IDB removed: ${path}`);
    },
    async list(dirPath){
      const man = (await idb.get('__manifest__'))||[];
      const pref = dirPath.replace(/\/+$/,'') + '/';
      const out = [];
      for(const p of man) {
        if(p.indexOf(pref)===0) {
          const rest = p.slice(pref.length);
          const head = rest.split('/')[0];
          if(!out.includes(head)) out.push(head);
        }
      }
      return out;
    }
  };

  // Storage facade
  const Storage = {
    mode: 'auto',
    adapter: null,
    async init(){
      const hasOPFS = !!(navigator.storage && navigator.storage.getDirectory);
      const hasPicker = !!window.showDirectoryPicker;
      if(hasPicker) {
        const ok = await FolderAdapter.restore().catch(()=>false);
        if(ok) { this.mode='folder'; this.adapter=FolderAdapter; setStatus('Connected Folder'); return; }
      }
      if(this.mode==='folder' && FolderAdapter.dirHandle) { this.adapter=FolderAdapter; setStatus('Connected Folder'); return; }
      if((this.mode==='auto') && hasOPFS) { this.adapter=OPFSAdapter; setStatus('OPFS'); try{ await navigator.storage.persist(); }catch{} return; }
      this.adapter = IDBAdapter; setStatus('IndexedDB');
    },
    setMode(m){ this.mode = m; },
    async put(path,data){ return this.adapter.put(path,data); },
    async get(path){ return this.adapter.get(path); },
    async list(path){ return this.adapter.list(path); },
    async remove(path){ return this.adapter.remove(path); }
  };

  // Domain helpers
  function newId(prefix){ const t = new Date().toISOString().replace(/[:.]/g,'-'); return `${prefix}-${t}`; }
  function getCurrentDreamText(){
    const el = document.getElementById('dreamText') || document.getElementById('dream');
    return el ? el.value.trim() : '';
  }

  async function refreshLibrary(){
    const listEl = document.getElementById('libraryList'); if(!listEl) return;
    listEl.innerHTML = 'Loading…';
    let files = [];
    try { files = await Storage.list('library/dreams'); } catch(e) { LOG('list error '+e); }
    if(!files || files.length===0) { listEl.innerHTML = '<em>No dreams saved yet.</em>'; return; }
    files = files.sort();
    listEl.innerHTML = files.map(name => `<label style="display:flex;gap:6px;align-items:center;padding:4px 0;">
      <input type="radio" name="dreamPick" value="${name}"> <span>${name}</span>
    </label>`).join('');
  }

  async function libSaveCurrent(){
    const text = getCurrentDreamText();
    if(!text) { LOG('Nothing to save (dream text empty)'); return; }
    const id = newId('dream');
    const payload = { id, createdAt: new Date().toISOString(), text };
    await Storage.put(`library/dreams/${id}.json`, payload);
    LOG('Saved dream: '+id);
    refreshLibrary();
  }

  async function libNewFromCurrent(){
    await libSaveCurrent();
  }

  async function libLoadSelected(){
    const pick = document.querySelector('input[name="dreamPick"]:checked');
    if(!pick) { LOG('No selection'); return; }
    const name = pick.value;
    const data = await Storage.get('library/dreams/'+name).catch(e=>{ LOG('load error '+e); return null; });
    if(data && data.text!==undefined) {
      const el = document.getElementById('dreamText') || document.getElementById('dream');
      if(el) el.value = data.text;
      LOG('Loaded dream into editor: '+name);
    } else LOG('Selected file not found or invalid.');
  }

  async function libDeleteSelected(){
    const pick = document.querySelector('input[name="dreamPick"]:checked');
    if(!pick) { LOG('No selection'); return; }
    const name = pick.value;
    await Storage.remove('library/dreams/'+name);
    LOG('Deleted: '+name);
    refreshLibrary();
  }

  function setupSettings(){
    const radios = document.querySelectorAll('input[name="storageMode"]');
    radios.forEach(r => r.addEventListener('change', async () => {
      Storage.setMode(r.value);
      await Storage.init();
      refreshLibrary();
    }));
    const btnConn = document.getElementById('connectFolder');
    if(btnConn) btnConn.addEventListener('click', async () => {
      try { await FolderAdapter.connect(); Storage.setMode('folder'); await Storage.init(); setStatus('Connected Folder'); refreshLibrary(); }
      catch(e) { LOG('Folder connect canceled/failed'); }
    });
    const btnRevoke = document.getElementById('revokeFolder');
    if(btnRevoke) btnRevoke.addEventListener('click', async () => {
      await idb.del('folderHandle'); FolderAdapter.dirHandle = null;
      Storage.setMode('auto'); await Storage.init(); setStatus('Disconnected; '+Storage.adapter.name); refreshLibrary();
      LOG('Disconnected folder handle');
    });
    const btnOpen = document.getElementById('openFolder');
    if(btnOpen) btnOpen.addEventListener('click', async () => {
      try { const h = await window.showDirectoryPicker({ id:'DreamApp', mode:'read' }); LOG('Folder opened (read-only check): '+(h.name||'selected')); }
      catch(e) { LOG('Open folder canceled'); }
    });
  }

  function setupLibrary(){
    const bNew = document.getElementById('libNew'); if(bNew) bNew.addEventListener('click', libNewFromCurrent);
    const bSave= document.getElementById('libSave'); if(bSave) bSave.addEventListener('click', libSaveCurrent);
    const bRef = document.getElementById('libRefresh'); if(bRef) bRef.addEventListener('click', refreshLibrary);
    const bLoad= document.getElementById('libLoad'); if(bLoad) bLoad.addEventListener('click', libLoadSelected);
    const bDel = document.getElementById('libDelete'); if(bDel) bDel.addEventListener('click', libDeleteSelected);
    const bClr = document.getElementById('logClear'); if(bClr) bClr.addEventListener('click', ()=>{ const el=document.getElementById('storageLog'); if(el) el.value=''; });
  }

  document.addEventListener('DOMContentLoaded', async () => {
    await Storage.init();
    setupSettings();
    setupLibrary();
    refreshLibrary();
    LOG('Storage ready: '+(Storage.adapter && Storage.adapter.name));
  });
})();
</script>

<!-- v4_4_6+ change: profiles & named dreams (built inline) -->
<script>
(function(){
  const LOG = (msg) => {
    const el = document.getElementById('storageLog'); if(!el) return;
    const t = new Date().toISOString().replace('T',' ').replace('Z','');
    el.value += `[${t}] ${msg}\n`; el.scrollTop = el.scrollHeight;
  };

  // tiny KV (reuse DB)
  const idb = (() => {
    const DB='DreamAppDB_v1', STORE='kv';
    function open(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
    async function put(k,v){ const db=await open(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).put(v,k); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }
    async function get(k){ const db=await open(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const req=tx.objectStore(STORE).get(k); req.onsuccess=()=>res(req.result??null); req.onerror=()=>rej(req.error); }); }
    async function del(k){ const db=await open(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).delete(k); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }
    return { put, get, del };
  })();

  // Profiles facade (reuses connected folder if present)
  const ProfilesStore = {
    adapter: null,
    folderHandle: null,
    async init(){
      try { this.folderHandle = await idb.get('folderHandle'); } catch(e) {}
      if (this.folderHandle && window.showDirectoryPicker) { this.adapter = FolderAdapter(this.folderHandle); LOG('ProfilesStore: folder'); return; }
      if (navigator.storage && navigator.storage.getDirectory) { this.adapter = OPFSAdapter(); LOG('ProfilesStore: opfs'); try{ await navigator.storage.persist(); }catch{} return; }
      this.adapter = IDBAdapter(); LOG('ProfilesStore: idb');
    },
    async put(path,data){ return this.adapter.put(path,data); },
    async get(path){ return this.adapter.get(path); },
    async list(path){ return this.adapter.list(path); },
    async remove(path){ return this.adapter.remove(path); },
    userName(){ return (this.folderHandle && this.folderHandle.name) ? this.folderHandle.name : 'Local'; },
    userBase(){ return `profiles/${this.userName()}`; }
  };

  function segs(p){ return p.split('/').filter(Boolean); }
  function FolderAdapter(dirHandleInit){ return {
      name:'folder', dirHandle:dirHandleInit,
      async ensureDir(path){ let d=this.dirHandle; for(const s of segs(path)) d=await d.getDirectoryHandle(s,{create:true}); return d; },
      async put(path,data){ const a=segs(path), f=a.pop(); const d=await this.ensureDir(a.join('/')); const fh=await d.getFileHandle(f,{create:true}); const w=await fh.createWritable(); await w.write(typeof data==='string'?data:JSON.stringify(data,null,2)); await w.close(); LOG('Folder saved: '+path); },
      async get(path){ const a=segs(path), f=a.pop(); let d=this.dirHandle; for(const s of a) d=await d.getDirectoryHandle(s); const fh=await d.getFileHandle(f); const t=await (await fh.getFile()).text(); try{ return JSON.parse(t); }catch{ return t; } },
      async remove(path){ const a=segs(path), f=a.pop(); let d=this.dirHandle; for(const s of a) d=await d.getDirectoryHandle(s); await d.removeEntry(f); LOG('Folder removed: '+path); },
      async list(path){ let d=this.dirHandle; for(const s of segs(path)) d=await d.getDirectoryHandle(s,{create:true}); const out=[]; for await(const [n] of d.entries()) out.push(n); return out; }
  }; }
  function OPFSAdapter(){ return {
      name:'opfs',
      async ensureDir(path){ let d=await navigator.storage.getDirectory(); for(const s of segs(path)) d=await d.getDirectoryHandle(s,{create:true}); return d; },
      async put(path,data){ const a=segs(path), f=a.pop(); const d=await this.ensureDir(a.join('/')); const fh=await d.getFileHandle(f,{create:true}); const w=await fh.createWritable(); await w.write(typeof data==='string'?data:JSON.stringify(data,null,2)); await w.close(); LOG('OPFS saved: '+path); },
      async get(path){ const a=segs(path), f=a.pop(); let d=await navigator.storage.getDirectory(); for(const s of a) d=await d.getDirectoryHandle(s); const fh=await d.getFileHandle(f); const t=await (await fh.getFile()).text(); try{ return JSON.parse(t); }catch{ return t; } },
      async remove(path){ const a=segs(path), f=a.pop(); let d=await navigator.storage.getDirectory(); for(const s of a) d=await d.getDirectoryHandle(s); await d.removeEntry(f); LOG('OPFS removed: '+path); },
      async list(path){ let d=await navigator.storage.getDirectory(); for(const s of segs(path)) d=await d.getDirectoryHandle(s,{create:true}); const out=[]; for await(const [n] of d.entries()) out.push(n); return out; }
  }; }
  function IDBAdapter(){ return {
      name:'idb',
      async put(path,data){ const s = typeof data==='string'?data:JSON.stringify(data,null,2); await idb.put('file:'+path, s); const man=(await idb.get('__manifest__'))||[]; if(!man.includes(path)){ man.push(path); await idb.put('__manifest__', man);} LOG('IDB saved: '+path); },
      async get(path){ const t = await idb.get('file:'+path); if(!t) return null; try{ return JSON.parse(t); }catch{ return t; } },
      async remove(path){ const man=(await idb.get('__manifest__'))||[]; const i=man.indexOf(path); if(i>=0) man.splice(i,1); await idb.put('__manifest__', man); await idb.del('file:'+path); LOG('IDB removed: '+path); },
      async list(dirPath){ const man=(await idb.get('__manifest__'))||[]; const pref=dirPath.replace(/\/*$/,'')+'/'; const out=[]; for(const p of man){ if(p.indexOf(pref)===0){ const head=p.slice(pref.length).split('/')[0]; if(!out.includes(head)) out.push(head);} } return out; }
  }; }

  const qs = (s,r=document)=>r.querySelector(s);
  const slugify = (s) => (s||'').toLowerCase().trim().replace(/[^a-z0-9\s_-]/g,'').replace(/\s+/g,'-').replace(/-+/g,'-').slice(0,80)||'untitled';

  function ensureUserBadge(){
    if(!document.getElementById('userBadge')){ const b=document.createElement('div'); b.id='userBadge'; b.textContent='User: '+ProfilesStore.userName(); document.body.appendChild(b); }
    else { document.getElementById('userBadge').textContent='User: '+ProfilesStore.userName(); }
  }
  function ensureDreamNameField(){
    const dreamEl=document.getElementById('dreamText')||document.getElementById('dream');
    if(!dreamEl||document.getElementById('dreamName')) return;
    const label=document.createElement('label'); label.textContent='Dream Name (not used in prompts)'; label.setAttribute('for','dreamName');
    label.style.display='block'; label.style.margin='8px 0 4px'; label.style.fontSize='12px'; label.style.color='var(--muted, #9aa3b2)';
    const input=document.createElement('input'); input.type='text'; input.id='dreamName'; input.placeholder='e.g., Warehouse Return';
    input.style.width='100%'; input.style.background='var(--panel-2, #1b1f2a)'; input.style.border='1px solid var(--border, #2a2f3a)'; input.style.color='var(--text, #e6e7ea)';
    input.style.borderRadius='8px'; input.style.padding='8px'; input.style.fontSize='14px';
    dreamEl.parentNode.insertBefore(input, dreamEl); dreamEl.parentNode.insertBefore(label, input);
  }
  function ensureLibraryControls(){
    const libWin=document.getElementById('win-library'); if(!libWin) return;
    const body=libWin.querySelector('.win__body, .body')||libWin; if(!body||document.getElementById('libOutputs')) return;
    const box=document.createElement('div'); box.id='libOutputs'; box.style.marginTop='10px';
    box.innerHTML = `
      <div class="win__actions" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0;">
        <button class="btn" id="libSaveDream">Save Dream</button>
        <button class="btn" id="libSaveInterp">Save Interpretation</button>
        <button class="btn" id="libSaveDepth">Save Depth Output</button>
        <button class="btn" id="libSaveWaking">Save Waking Output</button>
      </div>
      <div class="win__actions" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0;">
        <button class="btn" id="libLoadDream">Load Dream</button>
        <button class="btn" id="libLoadInterp">Load Interpretation</button>
        <button class="btn" id="libLoadDepth">Load Depth Output</button>
        <button class="btn" id="libLoadWaking">Load Waking Output</button>
      </div>`;
    const list=document.getElementById('libraryList'); (list&&list.parentNode?list.parentNode:body).appendChild(box);
    qs('#libSaveDream')?.addEventListener('click', saveDream);
    qs('#libSaveInterp')?.addEventListener('click', saveInterp);
    qs('#libSaveDepth')?.addEventListener('click', saveDepth);
    qs('#libSaveWaking')?.addEventListener('click', saveWaking);
    qs('#libLoadDream')?.addEventListener('click', () => loadArtifact('dream'));
    qs('#libLoadInterp')?.addEventListener('click', () => loadArtifact('interpretation'));
    qs('#libLoadDepth')?.addEventListener('click', () => loadArtifact('depth'));
    qs('#libLoadWaking')?.addEventListener('click', () => loadArtifact('waking'));
  }
  function selectedDreamSlug(){ const pick=document.querySelector('input[name="dreamPick"]:checked'); return pick?pick.value.replace(/\.json$/,''):null; }
  async function refreshLibraryPlus(){
    const listEl=document.getElementById('libraryList'); if(!listEl) return;
    listEl.innerHTML='Loading…';
    let names=[]; try { names = await ProfilesStore.list(`${ProfilesStore.userBase()}/dreams`); } catch(e){ LOG('list error '+e); }
    names=(names||[]).map(n=>n.replace(/\.json$/,'')).filter((v,i,a)=>a.indexOf(v)===i).sort();
    if(!names.length){ listEl.innerHTML='<em>No dreams saved yet.</em>'; return; }
    listEl.innerHTML = names.map(name => `
      <label style="display:flex;gap:6px;align-items:center;padding:4px 0;">
        <input type="radio" name="dreamPick" value="${name}"> <span>${name}</span>
      </label>`).join('');
  }

  const dreamPayload  = (name, text) => ({ name, text, updatedAt: new Date().toISOString() });
  const interpPayload = (name, text) => ({ name, interpretation: text, updatedAt: new Date().toISOString() });
  const depthPayload  = (name, text) => ({ name, depthOutput: text, updatedAt: new Date().toISOString() });
  const wakingPayload = (name, text) => ({ name, wakingOutput: text, updatedAt: new Date().toISOString() });

  async function saveDream(){
    const name = (document.getElementById('dreamName')?.value || '').toLowerCase().trim().replace(/[^a-z0-9\s_-]/g,'').replace(/\s+/g,'-').replace(/-+/g,'-').slice(0,80) || 'untitled';
    const text = (document.getElementById('dreamText')?.value || document.getElementById('dream')?.value || '').trim();
    if(!name || !text) { LOG('Save Dream: need dream name and text'); return; }
    await ProfilesStore.put(`${ProfilesStore.userBase()}/dreams/${name}/dream.json`, dreamPayload(name, text));
    LOG('Saved Dream → '+name); refreshLibraryPlus();
  }
  async function saveInterp(){
    const dn = document.getElementById('dreamName')?.value || '';
    const name = selectedDreamSlug() || dn.toLowerCase().trim().replace(/[^a-z0-9\s_-]/g,'').replace(/\s+/g,'-').replace(/-+/g,'-').slice(0,80) || 'untitled';
    const text = (document.getElementById('modelOutput')?.value || '').trim();
    if(!name || !text) { LOG('Save Interpretation: need dream name (select or type) and model output'); return; }
    await ProfilesStore.put(`${ProfilesStore.userBase()}/dreams/${name}/interpretation.json`, interpPayload(name, text));
    LOG('Saved Interpretation → '+name);
  }
  async function saveDepth(){
    const dn = document.getElementById('dreamName')?.value || '';
    const name = selectedDreamSlug() || dn.toLowerCase().trim().replace(/[^a-z0-9\s_-]/g,'').replace(/\s+/g,'-').replace(/-+/g,'-').slice(0,80) || 'untitled';
    const text = (document.getElementById('depthOutput')?.value || '').trim();
    if(!name || !text) { LOG('Save Depth: need dream name and depth output'); return; }
    await ProfilesStore.put(`${ProfilesStore.userBase()}/dreams/${name}/depth.json`, depthPayload(name, text));
    LOG('Saved Depth Output → '+name);
  }
  async function saveWaking(){
    const dn = document.getElementById('dreamName')?.value || '';
    const name = selectedDreamSlug() || dn.toLowerCase().trim().replace(/[^a-z0-9\s_-]/g,'').replace(/\s+/g,'-').replace(/-+/g,'-').slice(0,80) || 'untitled';
    const text = (document.getElementById('wakingContextOutput')?.value || '').trim();
    if(!name || !text) { LOG('Save Waking: need dream name and waking output'); return; }
    await ProfilesStore.put(`${ProfilesStore.userBase()}/dreams/${name}/waking.json`, wakingPayload(name, text));
    LOG('Saved Waking Output → '+name);
  }

  async function loadArtifact(kind){
    const name = selectedDreamSlug();
    if(!name) { LOG('Load '+kind+': select a dream first'); return; }
    const path = `${ProfilesStore.userBase()}/dreams/${name}/${kind==='dream'?'dream':kind}.json`;
    const data = await ProfilesStore.get(path).catch(e=>{ LOG('Load error '+e); return null; });
    if(!data) { LOG('Nothing loaded'); return; }
    if(kind==='dream'){
      const el = document.getElementById('dreamText') || document.getElementById('dream'); if(el) el.value = data.text||'';
      const dn = document.getElementById('dreamName'); if(dn) dn.value = data.name || name;
    } else if(kind==='interpretation'){
      const el = document.getElementById('modelOutput'); if(el) el.value = data.interpretation||'';
    } else if(kind==='depth'){
      const el = document.getElementById('depthOutput'); if(el) el.value = data.depthOutput||'';
    } else if(kind==='waking'){
      const el = document.getElementById('wakingContextOutput'); if(el) el.value = data.wakingOutput||'';
    }
    LOG('Loaded '+kind+' ← '+name);
  }

  function wireRefresh(){
    const b=document.getElementById('libRefresh');
    if(b && !b.dataset.plus){ b.dataset.plus='1'; b.addEventListener('click', refreshLibraryPlus); }
  }

  document.addEventListener('DOMContentLoaded', async () => {
    await ProfilesStore.init();
    ensureUserBadge();
    ensureDreamNameField();
    ensureLibraryControls();
    wireRefresh();
    refreshLibraryPlus();

    const settingsWin=document.getElementById('win-settings');
    if(settingsWin){ settingsWin.addEventListener('click', () => setTimeout(()=>{ ensureUserBadge(); refreshLibraryPlus(); }, 250)); }
  });
})();
</script>

<!-- user badge node -->
<div id="userBadge">User: Local</div>

</body>
</html>
